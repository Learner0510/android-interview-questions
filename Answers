Android Push Notification Flow using FCM

The Android push notification flow using Firebase Cloud Messaging (FCM) involves a few key steps and components:

    Client App Instance: When an app is installed on an Android device, the FCM SDK automatically generates a unique registration token. This token identifies the app instance on that specific device. The app should send this token to your app server.

    App Server: Your app server or a third-party server creates the notification payload. This payload can contain a notification field for a standard message (title, body, icon) and a data field for custom key-value pairs. The server then sends a request to the FCM server using this payload and the device's registration token.

    FCM Server: The FCM server receives the request, processes it, and routes the message to the target device. It handles the complexities of message delivery, even if the device is offline or in a low-power state (Doze mode).

    Device: The Android device receives the message from FCM. The behavior upon reception depends on the app's state:

        App in the background: If the payload contains a notification field, FCM displays the notification in the system tray. The app's onMessageReceived method is not called. The data payload is delivered to the app when the user taps the notification.

        App in the foreground: The onMessageReceived method of your app's FirebaseMessagingService is called immediately. The app receives the message object, which contains both notification and data payloads, and can handle the notification programmatically.

The main advantage of FCM is that it provides a reliable, cross-platform way to send messages without needing a constant open connection from your app to your server, which saves battery and resources.

What is an inline function in Kotlin?

An inline function in Kotlin is a function that the compiler replaces with the actual function body at the call site. This is a form of code substitution that happens during compilation, not runtime.

The primary purpose of using inline functions is to reduce the overhead of lambda expressions. When a function takes a lambda as a parameter, the lambda is an object that gets created and allocated in memory. By inlining the function, the compiler avoids creating this object, which can improve performance, especially in loops or frequently called functions.

Example:
Kotlin

// A regular function with a lambda
fun calculate(a: Int, b: Int, operation: (Int, Int) -> Int): Int {
    return operation(a, b)
}

// An inline function
inline fun calculateInline(a: Int, b: Int, operation: (Int, Int) -> Int): Int {
    return operation(a, b)
}

// The 'calculateInline' function call
// will be replaced by the compiler with:
// return a + b

What is the advantage of using const in Kotlin?

The primary advantage of using const in Kotlin is that it creates a compile-time constant. The value is "inlined" directly into the code wherever it's used, meaning there's no runtime overhead to access the variable. This provides a performance benefit.

Here are the key characteristics of a const property:

    It must be a val (immutable).

    It must be a top-level property, or a member of an object or a companion object.

    It must be initialized with a primitive type (String, Int, Boolean, etc.) or a String.

    The value must be known at compile time.

Example:
Kotlin

const val APP_NAME = "My Awesome App"

fun printAppName() {
    // The compiler replaces 'APP_NAME' with the literal "My Awesome App"
    println(APP_NAME)
}

What is a reified keyword in Kotlin?

The reified keyword in Kotlin is used with inline functions to access type information at runtime for a generic type parameter. Normally, generic type information is erased at compile time (a concept known as type erasure in the JVM). This means you cannot check the type of a generic parameter at runtime with operators like is or as.

By marking an inline function's type parameter as reified, the compiler replaces the generic type with its actual type during inlining, making it available for checks and operations at runtime.

Example:
Kotlin

// This will not compile due to type erasure
// fun <T> findByType(list: List<Any>): T? {
//    return list.find { it is T } // ERROR: Cannot check for T
// }

// With 'reified' in an inline function, it works
inline fun <reified T> findByType(list: List<Any>): T? {
    // The type 'T' is available at runtime
    return list.find { it is T } as T?
}

// Usage:
val myNumbers = listOf(1, "hello", 2, true)
val firstString: String? = findByType<String>(myNumbers)

Suspending vs Blocking in Kotlin Coroutines

The main difference between suspending and blocking in Kotlin Coroutines is how they manage the underlying thread's execution.

    Suspending: A suspending function (marked with the suspend keyword) can pause its execution without blocking the thread it's running on. This is the core of coroutine efficiency. When a suspending function needs to wait for a result (e.g., a network call), it "suspends" the coroutine, freeing the thread to perform other work. When the result is ready, the coroutine can resume on the same or a different thread. This leads to efficient resource utilization and non-blocking I/O.

    Blocking: A blocking operation stops the thread's execution completely until the operation is finished. While the thread is blocked, it cannot do any other work. Using blocking calls on the main thread, for instance, will freeze the UI and can lead to an "Application Not Responding" (ANR) error. Blocking is simple but can be inefficient and should be avoided for long-running operations.

In summary, suspending is a cooperative mechanism that allows a thread to be shared among many coroutines, while blocking is a more traditional, exclusive approach where one thread is dedicated to a single task.

Launch vs Async in Kotlin Coroutines

launch and async are coroutine builders used to start a new coroutine. The key difference lies in how they handle their return value and the purpose they serve.

    launch: This is a "fire-and-forget" coroutine builder. It returns a Job object, which represents the coroutine's lifecycle and allows you to cancel or wait for its completion. launch is used for tasks that don't need to return a result to the caller, such as updating a database, logging, or performing a UI-related action. It's a non-blocking way to start a task.

    async: This coroutine builder is used for tasks that need to return a result. It returns a Deferred<T> object, which is a lightweight non-blocking future. You can retrieve the result of the computation by calling .await() on the Deferred object. This function suspends the coroutine until the result is available. async is ideal for performing multiple asynchronous tasks in parallel and then waiting for all their results.

Analogy: Think of launch as sending an email—you send it and don't wait for a reply. async is like asking a question—you ask it and then wait for an answer.

internal visibility modifier in Kotlin

The internal visibility modifier in Kotlin restricts the visibility of a declaration to the current module. A module is a set of Kotlin files that are compiled together, such as:

    An Android Studio module.

    A Maven or Gradle project.

    A set of files compiled by one kotlinc invocation.

If you declare a class, function, or property as internal, it can be accessed from any file within the same module, but it's not visible to code outside of that module. This is useful for encapsulating implementation details within a project without exposing them to other projects or libraries.

Example:
Kotlin

// Module 'app-module'
internal class InternalService {
    internal fun doInternalWork() {
        // ...
    }
}

In another module, say feature-module, you would not be able to access InternalService or doInternalWork().

open keyword in Kotlin

The open keyword in Kotlin is used to make a class or a class member (property or function) open for inheritance. By default, all classes and members in Kotlin are final, which means they cannot be subclassed or overridden. This is a design choice to promote composition over inheritance and prevent unexpected behavior caused by subclassing.

To allow a class to be extended or a member to be overridden, you must explicitly mark it with the open keyword.

Example:
Kotlin

// This class can be inherited
open class Animal {
    // This function can be overridden
    open fun makeSound() {
        println("The animal makes a sound")
    }
}

// Dog can inherit from Animal
class Dog : Animal() {
    // This function overrides the base class's function
    override fun makeSound() {
        println("Woof!")
    }
}

lateinit vs lazy in Kotlin

lateinit and lazy are both ways to initialize a non-null property in Kotlin at a later point, but they serve different purposes and have distinct characteristics.
Feature	lateinit	lazy
Purpose	Used when you know the property will be initialized before its first use, but its value cannot be set in the constructor. Common for dependency injection.	Used for a property whose value is expensive to create and you want to initialize it only when it's first accessed.
Type	Can only be used with var (mutable) properties.	Can only be used with val (immutable) properties.
Nullability	Must be a non-nullable type. No null check is needed, but an exception will be thrown if accessed before initialization.	The property is non-nullable and guaranteed to be initialized on first access.
Thread Safety	Not thread-safe by default.	Thread-safe by default. The lazy delegate provides different modes (SYNCHRONIZED, PUBLICATION, NONE) to control this.
Usage Example	lateinit var myService: MyService	val myExpensiveObject: SomeObject by lazy { SomeObject() }

Summary: Use lateinit for mutable properties that will be initialized externally, and lazy for immutable, expensive-to-create properties that you want to initialize on demand.

What is Multidex in Android?

Multidex is a mechanism in Android that allows an app to use more than 65,536 method references. This limit is due to the Dalvik Executable (DEX) file format, which has a 16-bit field for indexing methods.

When an app grows in size and complexity—due to its own code, libraries, and frameworks—it can exceed this method count limit. When this happens, the compiler will fail with an error. Multidex solves this by generating multiple DEX files for the app. The primary DEX file contains the initial code and a reference to load additional DEX files, allowing the app to bypass the 65k limit.

You enable it by adding multiDexEnabled true to your app-level build.gradle file.

How does the Android Push Notification system work?

The Android Push Notification system works through a chain of communication between your app server, a cloud messaging service, and the user's device. Here's the general flow:

    Registration: When a user's device registers with your app, the app's backend server sends a request to a cloud messaging service, such as Firebase Cloud Messaging (FCM), to obtain a unique registration token for that device.

    Message Creation: Your app server or a third-party server decides to send a push notification. It creates a message payload containing the notification content (title, body, etc.) and the device's unique registration token.

    Sending: The app server sends the message payload to the cloud messaging service.

    Delivery: The cloud messaging service (FCM) receives the message and pushes it to the target Android device via a persistent connection. This service is part of the Android OS and is highly optimized to handle notifications efficiently, even when the device is in a low-power state.

    Reception: The Android OS receives the message. If the app is in the background, the OS displays the notification in the notification bar. If the app is in the foreground, the message is delivered directly to your app's code for you to handle programmatically.

How does the Kotlin Multiplatform work?

Kotlin Multiplatform (KMP) is a technology by JetBrains that allows developers to share code across multiple platforms while keeping the user interface (UI) native. It works by having a core "common" module where you write business logic, networking, data handling, and other non-UI code in Kotlin.

KMP uses a set of compilers to translate this common Kotlin code into platform-specific binaries:

    Kotlin/JVM: Compiles Kotlin code into JVM bytecode for Android, desktop, and backend applications.

    Kotlin/Native: Compiles Kotlin code into native binaries for platforms like iOS, macOS, watchOS, and Linux. This allows direct access to platform APIs and interoperability with languages like Swift and Objective-C.

    Kotlin/JS: Compiles Kotlin code to JavaScript for web applications.

For platform-specific features that can't be implemented in the common module (e.g., accessing a device's camera or a platform-specific API), KMP uses the expect/actual mechanism. You declare an expect function or class in the common module, and then provide a platform-specific actual implementation in each platform module. This allows you to write the same high-level logic and call the appropriate native implementation transparently.

What is a ViewModel and how is it useful?

A ViewModel is a class from the Android Jetpack Architecture Components library. It is designed to store and manage UI-related data in a lifecycle-aware way.

Its primary purpose is to survive configuration changes, such as screen rotations. When an Activity or Fragment is destroyed and recreated due to a configuration change, the ViewModel instance is retained. This prevents you from losing the data you've fetched or processed, and avoids unnecessary network calls or database queries.

Key advantages:

    Lifecycle Awareness: It can observe the lifecycle of a Fragment or Activity and hold data until the associated Activity or Fragment is completely finished (e.g., the user navigates away).

    Separation of Concerns: It separates the UI logic (Activity/Fragment) from the business logic and data handling, making the code cleaner, more testable, and easier to maintain.

    Data Persistence: It ensures that data is not lost on configuration changes, providing a better user experience.

Is it possible to force Garbage Collection in Android?

No, you cannot truly force garbage collection (GC) in Android. You can only suggest it to the system by calling System.gc() or Runtime.getRuntime().gc().

However, these calls are just a hint, and the Android runtime is highly optimized to decide when the best time to run the GC is. Calling it yourself is generally discouraged as it can introduce performance issues, like temporary UI stuttering, by unexpectedly interrupting the system's operations. The system's garbage collector is designed to run automatically and efficiently when needed, such as when heap memory is getting low.

A better practice is to focus on avoiding memory leaks by properly managing object lifecycles, and allowing the system to handle memory cleanup on its own.

What is a JvmStatic Annotation in Kotlin?

The @JvmStatic annotation in Kotlin is used to expose a function or property defined inside a companion object or a named object as a static member to Java code.

In Kotlin, companion objects and named objects are compiled as singleton classes. Their members are instance methods of these singleton classes, not true static methods. @JvmStatic instructs the Kotlin compiler to generate a true static method for a function or a static field for a property in the bytecode, making it directly callable from Java without needing the INSTANCE singleton reference.

Example:
Kotlin

// Kotlin code
class MyClass {
    companion object {
        @JvmStatic
        fun myStaticMethod() {
            println("Hello from a static method")
        }
    }
}

// Java code
// Can be called directly without the `INSTANCE`
MyClass.myStaticMethod();

init block in Kotlin

The init block in Kotlin is a special block of code that is executed as part of a class's primary constructor. It's used to put initialization code that can't be placed directly in the primary constructor's parameter list.

When a new instance of a class is created, the init block runs immediately after the primary constructor's parameters are processed. If a class has multiple init blocks, they are executed sequentially in the order they appear in the class body.

Example:
Kotlin

class User(name: String) {
    val username: String

    init {
        // This code runs when the class is initialized
        username = name.toUpperCase()
        println("User '$username' has been created.")
    }
}

// Creating an instance will print the message
val user = User("john doe")
// Output: User 'JOHN DOE' has been created.

JvmField Annotation in Kotlin

The @JvmField annotation in Kotlin is used to expose a property as a public field in Java, rather than as a property with generated getters and setters.

By default, Kotlin properties are compiled with getters (for val properties) and both getters and setters (for var properties). This is part of Kotlin's property-based design. When you need to interact with a Java library that expects a public field, or for performance-critical scenarios where direct field access is more efficient, @JvmField can be used.

Example:
Kotlin

// Kotlin code
class MyData {
    // This will be a public field in Java
    @JvmField
    val myName: String = "John"
}

// Java code
// Direct access to the field, no getter is generated
MyData myData = new MyData();
String name = myData.myName;

This annotation can only be used on non-private properties, and it cannot be used with properties that have custom getters or setters.

singleTask launchMode in Android

singleTask is an Android Activity launch mode. It dictates how a new instance of an activity is created and managed within the Android task stack.

When an activity with singleTask launch mode is started:

    The system searches for an existing instance of this activity in the current task stack.

    If an instance exists, the system does not create a new one. Instead, it brings the existing instance to the top of the stack and calls its onNewIntent() method. All other activities on top of this instance in the stack are destroyed.

    If an instance does not exist, a new instance is created and placed at the top of the stack.

singleTask is useful for activities that should have only one instance running at a time, such as a main dashboard or home screen. It prevents the creation of duplicate instances and ensures a consistent user experience.

Difference between == and === in Kotlin

In Kotlin, == and === perform different types of equality checks.

    == (Structural Equality): This operator checks if the content of two objects is the same. It is translated to a call to the .equals() method. For primitive types, it performs a simple value comparison. For data classes, == automatically checks for equality of all properties.

    === (Referential Equality): This operator checks if two references point to the exact same object in memory. It's a strict identity comparison. For primitive types, === is the same as ==.

Example:
Kotlin

val a = "hello"
val b = "hello"
val c = a

println(a == b) // true (content is the same)
println(a === b) // true (in this case, string literal optimization makes them the same object)

val list1 = listOf(1, 2, 3)
val list2 = listOf(1, 2, 3)

println(list1 == list2) // true (structural equality, content is the same)
println(list1 === list2) // false (referential equality, they are different objects in memory)

JvmOverloads Annotation in Kotlin

The @JvmOverloads annotation in Kotlin is used to improve interoperability with Java. When you have a Kotlin function with default parameter values, the Kotlin compiler generates only a single function with all parameters. This can be problematic for Java callers, who can't use the default values.

By adding @JvmOverloads, you instruct the Kotlin compiler to generate multiple overloaded methods for that function in the bytecode. Each overloaded method will have a different number of parameters, corresponding to the default values you've provided. This allows Java code to call the function with any number of parameters, just like a standard overloaded Java method.

Example:
Kotlin

// Kotlin code
class Greeter {
    @JvmOverloads
    fun sayHello(message: String = "Hello", name: String = "World") {
        println("$message, $name!")
    }
}

// Java code
Greeter greeter = new Greeter();
greeter.sayHello(); // Calls sayHello(String, String) with default values
greeter.sayHello("Hi"); // Calls sayHello(String, String) with "Hi" and default name
greeter.sayHello("Hi", "John"); // Calls sayHello(String, String)

Why is it recommended to use only the default constructor to create a Fragment?

It is strongly recommended to use only the default (no-argument) constructor to create a Fragment because of how the Android system handles fragment lifecycle and state restoration.

When Android needs to recreate an Activity (e.g., after a configuration change or process death), it also needs to recreate its Fragments. The system does this by using reflection to find and call the fragment's default constructor. If you use a parameterized constructor, the system won't know how to pass the necessary arguments, leading to a Fragment.InstantiationException and a crash.

To pass data to a Fragment, the correct and safe approach is to use a Bundle and the setArguments() method. This Bundle is automatically saved and restored by the system, ensuring that the data is available when the fragment is recreated.

Best Practice:
Kotlin

class MyFragment : Fragment() {
    companion object {
        fun newInstance(data: String): MyFragment {
            val fragment = MyFragment()
            val args = Bundle()
            args.putString("key_data", data)
            fragment.arguments = args
            return fragment
        }
    }
}

Why do we need to call setContentView() in onCreate() of Activity class?

You need to call setContentView() in the onCreate() method of an Activity because it's the method that sets the user interface layout for the activity.

The onCreate() method is the first lifecycle callback, called when the activity is being created. It's the ideal place to perform all your essential setup, and setting the content view is a critical part of that. The setContentView() method takes a layout resource ID and inflates the XML layout file, attaching it to the activity's window. Without this call, your activity would have no UI to display.

When only onDestroy is called for an activity without onPause() and onStop()?

It is rare for an Activity's onDestroy() to be called without onPause() and onStop() first, as the normal lifecycle flow is onPause() -> onStop() -> onDestroy(). However, this can happen when the Android system decides to kill the app's process entirely for memory-reclamation purposes.

This scenario, often referred to as "process death," can occur when the app has been in the background for a long time and the system needs to free up resources for other apps. In this case, the system doesn't bother with the orderly shutdown of each component's lifecycle methods (onPause(), onStop()) and simply terminates the process.

This is a key reason why you should always save important state and data in onPause() or onStop() and not rely on onDestroy() to be called.
